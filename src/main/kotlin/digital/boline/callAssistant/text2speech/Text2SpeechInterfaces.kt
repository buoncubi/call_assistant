package digital.boline.callAssistant.text2speech

import digital.boline.callAssistant.Loggable
import digital.boline.callAssistant.LoggableInterface
import kotlinx.coroutines.CoroutineScope
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.Job
import kotlinx.coroutines.launch
import kotlinx.coroutines.sync.Mutex
import kotlinx.coroutines.sync.withLock


/**
 * An interface for text-to-speech functionality. This interface provides methods to convert text into audio, playAudio
 * audio, start and stop text-to-speech operations, and simplify text playback. These methods should be performed
 * asynchronously.
 *
 * @param T The type representing the audio stream to playAudio the output generated by the text-to-speech process.
 *
 * @see Text2SpeechAsync
 * @see AwsPollyMute
 * @see AwsPolly
 *
 * @author Luca Buoncompagni © 2025
 */
interface Text2SpeechInterface<T>: LoggableInterface {

    /**
     * Indicates whether the text-to-speech operation is currently running.
     *
     * @return `true` if the text-to-speech operation is active; `false` otherwise.
     */
    fun isRunning(): Boolean // It is a `fun` instead of a `var` to assure that the flag is private.


    /**
     * Starts the text-to-speech service.
     *
     * @return `true` if the text-to-speech operation was successfully started; `false` otherwise.
     */
    fun start(): Boolean


    /**
     * Stops the text-to-speech service.
     *
     * @return `true` if the text-to-speech operation was successfully stopped; `false` otherwise.
     */
    fun stop(): Boolean


    /**
     * Converts the given text into an audio representation. This method is exploited by `speak()`.
     * 
     * This is the only method of this interface that do not check for [isRunning], which should be done in the derived
     * function (i.e., cannot fetch the audio of a stopped service).
     *
     * @param text The text to be synthesized into audio.
     *
     * @return The audio representation of the input text, with the type [T] determined by the implementation. It might
     * return `null` if it was not possible to retrieve the audio.
     */
    fun fetchAudio(text: String): T?


    /**
     * Plays the provided audio representation of the text.
     *
     * @return Returns `true` if the audio was successfully played; `false`  otherwise.
     */
    fun playAudio(audio: T): Boolean


    /**
     * Converts the given text into speech and plays the audio representation. If the fetched audio  is not `null`,
     * this method uses [fetchAudio] and [playAudio] (i.e., `playAudio(fetchAudio(text))`)
     *
     * @param text The text to be synthesized into speech and played.
     *
     * @return Returns `true` if the process ended successfully, `false` otherwise.
     */
    fun speak(text: String): Boolean {
        val audio = fetchAudio(text) ?: return false
        return playAudio(audio)
    }
}



/**
 * Abstract class for implementing asynchronous text-to-speech functionality based on the [Text2SpeechInterface]. It
 * provides mechanisms to fetch audio, playAudio audio, and perform text-to-speech operations asynchronously while
 * ensuring thread safety through the use of mutexes. It also provides basic implementation of the [serverRunning] flag,
 * but further management of the flag is left to the derived classes through the [start] and [stop] methods.
 *
 * @param T The type representing the audio stream to playAudio, determined by the concrete implementation.
 *
 * @property serverRunning A flag to identify if the service is currently running or not (this property is `protected`,
 * and it should be used only by derived classes).
 *
 * @see [Text2SpeechInterface]
 * @see [AwsPollyMute]
 * @see [AwsPolly]
 *
 * @author Luca Buoncompagni © 2025
 */
abstract class Text2SpeechAsync<T> : Text2SpeechInterface<T>, Loggable() {

    // Mutexes for synchronizing `fetchAudio` and `playAudio` methods
    private val fetchAudioMutex = Mutex()
    private val playMutex = Mutex()

    // Global coroutine scope optimized for I/O tasks where asynchronous tasks will run.
    private val scope = CoroutineScope(Dispatchers.IO)

    // It is set as a private var such that it is not mutable from outside this class (see `isRunning()`).
    protected var serverRunning: Boolean = false


    /**
     * Represents the running state of the [AwsPollyMute] process, which is implemented by the [Text2SpeechInterface].
     *
     * This variable indicates if the operations within the class are currently active. A value of `true` implies that
     * the service started, whereas a value of `false` implies that it stooped. If it is `false`, it is not possible to
     * [fetchAudio], [playAudio] (and [speak]) even asynchronously.
     *
     * @return `true` if the instance is running; otherwise, `false`.
     */
    override fun isRunning(): Boolean {
        return serverRunning
    }


    /**
     * Asynchronously fetches audio for the provided `text` and executes the given `callback` with the audio result as
     * soon as it is ready.
     * 
     * If there is an error while fetching the audio, the `callback` will receive a `null` input parameter. This
     * function ensures thread-safety during the audio fetching process, and it is based on the [fetchAudio] method.
     *
     * @param text The text for which audio is to be fetched.
     *
     * @param callback An optional function to be invoked with the fetched audio object, which can be `null` if audio
     * fetching fails.
     *
     * @return A [Job] representing the coroutine scope in which the audio fetching operation is executed.
     */
    fun fetchAudioAsync(text: String, callback: (T?) -> Unit = {}): Job {
        val job = scope.launch {
            fetchAudioMutex.withLock {
                val audioResult = fetchAudio(text)
                if (audioResult == null) {
                    logError("Cannot get asynchronous audio for text: '{}'.", text)
                }
                callback(audioResult)
            }
        }
        return job
    }


    /**
     * Asynchronously plays the provided audio and invokes the given callback upon completion. If there was an error
     * during audio playing the callback will receive a `false` input parameter; otherwise, `true` will be given.
     * 
     * The method ensures thread-safety during the playback process using a mutex, and it is based on the [playAudio]
     * method.
     *
     * @param audio The audio instance to be played.
     *
     * @param callback An optional callback function that will be invoked with a `Boolean` value indicating whether the
     * playback was successful (`true`) or not (`false`).
     *
     * @return A [Job] representing the coroutine scope in which the playback operation is executed.
     */
    fun playAudioAsync(audio: T, callback: (Boolean) -> Unit = {}): Job {
        val job = scope.launch {
            playMutex.withLock {
                val playResult = playAudio(audio)
                if (!playResult) {
                    logError("Cannot playAudio audio asynchronously.")
                }
                callback(playResult)
            }
        }
        return job
    }


    /**
     * Asynchronously converts the given `text` to speech and plays the audio. When the audio has been fetched and
     * played, the callback is invoked with a flag to identify the process success.
     * 
     * This method ensures thread-safety for both the fetching and playback processes, and it is based on the [speak]
     * method.
     *
     * @param text The text to be converted to audio and played.
     *
     * @param callback An optional callback function that will be invoked with `true` if the operation completes
     * successfully, or `false` if an error occurs.
     *
     * @return A [Job] representing the coroutine scope in which the text-to-speech operation is executed.
     */
    fun speakAsync(text: String, callback: (Boolean) -> Unit): Job {
        val job = scope.launch {
            fetchAudioMutex.withLock {
                val success = speak(text)
                callback(success)
            }
        }
        return job
    }


    /**
     * Starts the text-to-speech process. This method initiates the process of converting text to speech and preparing
     * for playback.
     *
     * This implementation already check for [serverRunning] flag and returns `false` if it is already running. However, be
     * sure to set the [serverRunning] flag if this method successfully started running.
     *
     * @return `true` if the text-to-speech operation was successfully started; `false` otherwise.
     */
    override fun start(): Boolean{
        if (isRunning()) {
            logWarn("Starting a client already started.")
            return false
        }
        return true
    }


    /**
     * Stops the text-to-speech operation. This method halts any ongoing processes related to text synthesis or audio
     * playback. It ensures that no further text-to-speech output is generated or played until explicitly restarted.
     *
     * This implementation already check for [serverRunning] flag and returns `false` if it is not running. However, be sure
     * to reset the `isRunning` flag if this method successfully stopped running.
     *
     * @return `true` if the text-to-speech operation was successfully stopped; `false` otherwise.
     */
    override fun stop(): Boolean {
        if (!isRunning()) {
            logWarn("Stopping a client already stopped.")
            return false
        }
        return true
    }


    /**
     * Plays the provided audio representation. This method requires an audio from [fetchAudio] and it is exploited by
     * [speak].
     *
     * This implementation already check for [serverRunning] flag and returns `false` if it is not running (i.e., it is not
     * possible to play the audio of a stopped service).
     *
     * @param audio The audio of type [T] to be played. This is the output generated by the text-to-speech process,
     * specific to the implementation.
     *
     * @return Returns `true` if the audio was successfully played; `false`  otherwise.
     */
    override fun playAudio(audio: T): Boolean {
        if (!isRunning()) {
            logWarn("Playing text from a stopped client.")
            return false
        }
        return true
    }
}