package llmInterface.prompt

import kotlinx.serialization.ExperimentalSerializationApi
import kotlinx.serialization.Serializable
import kotlinx.serialization.Transient
import kotlinx.serialization.json.Json
import kotlinx.serialization.protobuf.ProtoBuf
import java.io.File

// TODO set Logger and manage logs on the whole file


/**
 * A type alias representing an immutable list of [Occurrence].
 *
 * This alias represents the values in the map accessible through
 * [PromptsManager.variables]. This type is ment to collect immutable
 * data to be used at run time (i.e., after deserialization).
 *
 * @see Occurrence,
 * @see MutableOccurrences
 * @see SimplePrompt
 * @see PromptsManager
 * @see PromptsManagerImpl
 * @see PromptsDeserializer
 * @see ParsedPrompts.getPromptManager
 *
 * @author Luca Buoncompagni © 2025
 */
typealias Occurrences = List<Occurrence>


/**
 * A type alias representing a mutable list of [Occurrence].
 *
 * This alias represents the values in the map accessible through
 * [ParsedPrompts.variables]. This type is ment to collect mutable
 * data to be used while parsing prompts offline.
 *
 * @see Occurrences,
 * @see MutableOccurrences
 * @see SimplePrompt
 * @see ParsedPrompts
 * @see PromptsManager
 * @see PromptsManagerImpl
 * @see PromptsParser.storeVariablesOccurrences
 *
 * @author Luca Buoncompagni © 2025
 */
typealias MutableOccurrences = ArrayList<Occurrence>



/**
 * Represents the occurrence of a variable within a prompt section.
 *
 * It is used to represent the values of the [SimplePrompt.variables] map,
 * which is extended by the [ParsedPrompts] and [PromptsManager] classed.
 *
 * This class is serialized  into Json and Byte file by [ParsedPrompts], and
 * deserialized through [PromptsDeserializer].
 *
 * @property functionName The name of the function associated with a variable.
 * @property indexStart The indexes in the prompt where the variable placeholder starts.
 * @property indexEnd The indexes in the prompt where the variable placeholder ends.
 *
 * @see Occurrences
 * @see MutableOccurrences
 * @see SimplePrompt
 * @see ParsedPrompts
 * @see PromptsManager
 * @see PromptsManagerImpl
 *
 * @author Luca Buoncompagni © 2025
 */
@Serializable
data class Occurrence(val functionName: String, val indexStart: Int, val indexEnd: Int) {



    /**
     * Write the occurrence data in a json-like format.
     *
     * @return A string containing the human-readable format of the occurrence data.
     */
    override fun toString(): String {
        return "{'variableName': '$functionName', 'indexStart': $indexStart, 'indexEnd': $indexEnd}"
    }
}



/**
 * Represents a parsed and mutable set of prompt-related data, including [metadata], [constants],
 * [variablesDefinition], [variables] occurrences, and [prompts] content.
 *
 * This class allow to parse [prompts] contents where [constants] placeholder are filled with relative
 * value at parsing time. However, [variables] placeholders are still in place, and they will be filled
 * by the [PromptsManager.applyVariables] mechanisms at runtime.
 *
 * This class is designed to encapsulate the parsed results, and it is generated by [PromptsParser.parse].
 * For being efficient, this class is not ment to be used at runtime, but offline. Then, its data can
 * be store in a Json or Binary file for being efficiently used at runtime (see [serializeJson] and
 * [serializeBinary]).
 *
 *
 * @property prompts See [TypedPrompts.prompts]. In this implementation prompts might have [constants]
 * placeholder which are filled at parsing time.
 *
 * @property metadata See [TypedPrompts.metadata].
 *
 * @property variables See [TypedPrompts.variables].
 *
 * @property variablesDefinition A map containing the definitions of variables, where keys are variables
 * name, and values are their respective function names as defined in [VariablesFunction]. This property
 * is not serialized into files.
 *
 * @property constants A key-value map definition of constants as a pair of constants name and its value.
 * This property is not serialized into files.
 *
 * @property rawText The raw prompt text as given before parsing. It is used only for testing purposes.
 * and, by default its value is an empty string.
 *
 *
 * @see PromptsParser.parse
 * @see TypedPrompts
 * @see PromptsDeserializer
 * @see PromptsManager
 *
 *
 * @author Luca Buoncompagni © 2025
 */
@Serializable
data class ParsedPrompts(@Transient val rawText: String = ""): TypedPrompts() {

    // The properties of this class documented above.
    override val metadata = HashMap<String, String>()
    override val variables = HashMap<String, Occurrences>()
    override val prompts = HashMap<String, String>()

    // Not serialized data.
    @Transient val constants = HashMap<String, String>()
    @Transient val variablesDefinition = HashMap<String, String>()


    /**
     * Saves the current object as a JSON string to the specified file path.
     *
     * The JSON is serialized using [Json.encodeToString] with `pretty-print`
     * configuration for human readability. Use [serializeBinary] for better
     * performance at runtime.
     *
     * @param filePath The path to the file where the JSON string of the object will be saved.
     *
     * @return `true` if the JSON string was successfully saved, `false` otherwise.
     */
    fun serializeJson(filePath: String): Boolean {
        return serializeJson(File(filePath))
    }


    /**
     * Saves the current object as a JSON string to the specified file.
     * The JSON is serialized using [Json.encodeToString] with `pretty-print`
     * configuration for human readability. Use [serializeBinary] for better
     * performances at runtime.
     *
     * @param file The target file where the JSON string of the object will be saved.
     *
     * @return `true` if the JSON string was successfully saved, `false` otherwise.
     */
    fun serializeJson(file: File): Boolean {
        return serialize(file) {
            val json by lazy { Json { prettyPrint = true } }
            json.encodeToString(serializer(), this)
        }
    }


    /**
     * Saves the current object in a binary format to the specified file path.
     * The object is serialized using [ProtoBuf.decodeFromByteArray] and stored in the
     * specified file. Use [serializeJson] for readability but fewer performances.
     *
     * @param filePath The path to the file where the binary data will be saved.
     *
     * @return `true` if the JSON string was successfully saved, `false` otherwise.
     */
    fun serializeBinary(filePath: String): Boolean {
        return serializeBinary(File(filePath))
    }


    /**
     * Saves the current object in a binary format to the specified file.
     * The object is serialized into a byte array using [ProtoBuf.decodeFromByteArray].
     * Use [serializeJson] for readability but fewer performances.
     *
     * @param file The target file where the binary data of the object will be saved.
     *
     * @return `true` if the JSON string was successfully saved, `false` otherwise.
     */
    @OptIn(ExperimentalSerializationApi::class) // TODO check for not experimental library
    fun serializeBinary(file: File): Boolean {
        return serialize(file) {
            ProtoBuf.encodeToByteArray(serializer(), this)
        }
    }


    /**
     * Saves the given data to a specified file. The data is determined by the `getData` lambda.
     * The latter provides the data to be saved, which should be of type `ByteArray` or `String`
     * only.
     *
     * @param T The type of processable data, which should be either `ByteArray` or `String`.
     *
     * @param file The target file where data will be saved.
     *
     * @param getData A lambda function that provides the data to be saved.
     * The data can be of type `ByteArray` or `String` only.
     *
     * @return `true` if the JSON string was successfully saved, `false` otherwise.
     */
    private inline fun <reified T> serialize(file: File, getData:  () -> T ): Boolean {
        try {
            when (val data = getData()) {
                is ByteArray -> file.writeBytes(data) // Save ByteArray to the file
                is String -> file.writeText(data)      // Save String as text
                else -> println("ERROR unsupported serialized data type to write to '${file.path}'.")
            }
            println("ParsedPrompts successfully saved to '${file.path}'.")
            return true
        }catch (ex: Exception){
            println("Error on saving prompt serialized data in '${file.path}'. ${ex.message}")
            ex.printStackTrace()
            return false
        }
    }


    /**
     * Returns a [PromptsManager] instance containing an immutable copy of the data parsed
     * from a prompt files. This actual implementation returns an instance of [PromptsManagerImpl].
     *
     * This is the class that should be used at runtime, and it is the same data given by
     * [PromptsDeserializer]. It is recommender to use this function directly only on a
     * development environment.
     *
     * @return A [PromptsManager] instance with [metadata], [variables] occurrences, and
     * [prompts] equal to `this`class but immutable.
     */
    fun getPromptManager(): PromptsManager {
        return PromptsManagerImpl(this)
    }


    /**
     * Returns a string representation that shows all the properties of `this` classin a
     * human-readable manner.
     *
     * @return A string representation of the MutableParsedResults object on multiple lines.
     */
    override fun toString(): String {
        val sep = "\n\t\t"
        return "${this.javaClass.simpleName}(\n" +
                "\tmetadata = ${formatMap2String(metadata)},\n" +
                "\tvariablesDefinition = ${formatMap2String(variablesDefinition)},\n" +
                "\tconstants = ${formatMap2String(constants)},\n" +
                "\tvariables = ${formatMap2String(variables, ",$sep", sep)},\n" +
                "\tprompts = ${formatMap2String(prompts,",$sep", sep)}\n" +
                ")"
    }

}


/**
 * An object that can be used to deserialize [ParsedPrompts] from file, either
 * from a Json or Binary format.
 *
 * This class should be used at runtime to have access to [PromptsManager] after
 * that a [ParsedPrompts] has been generated by [PromptsParser] and serialized into
 * a file.
 *
 * @see PromptsManager
 * @see ParsedPrompts
 *
 * @author Luca Buoncompagni © 2025
 */
object PromptsDeserializer {

    /**
     * Loads and deserializes prompt data from the specified file path.
     * Such a file should be stored through [ParsedPrompts.serializeJson]
     * or [ParsedPrompts.serializeBinary].
     *
     * This method attempts to deserialize [ParsedPrompts] object from binary first.
     * If an error occurs, it attempts to deserialize the data as a JSON string
     * and, even if this fails, it logs an error and returns `null`.
     *
     * @param filePath The path to the file containing the serialized prompt data to load.
     *
     * @return An instance of [PromptsManagerImpl] containing the deserialized
     * data, or `null` if deserialization fails.
     */
    fun fromBytesOrJson(filePath: String): PromptsManager? {
        return fromBytesOrJson(File(filePath))
    }


    /**
     * Loads and deserializes prompt data from the specified file path.
     * Such a file should be stored through [ParsedPrompts.serializeJson]
     * or [ParsedPrompts.serializeBinary].
     *
     * This method attempts to deserialize [PromptsManager] object from binary first.
     * If an error occurs, it attempts to deserialize the data as a JSON string
     * and, even if this fails, it logs an error and returns `null`.
     *
     * @param file The file containing the serialized prompt data to load.
     *
     * @return An instance of [PromptsManagerImpl] containing the deserialized
     * data, or `null` if deserialization fails.
     */
    fun fromBytesOrJson(file: File): PromptsManager? {
        val fromByte = fromBytes(file)
        if (fromByte != null) return fromByte

        val fromJson = fromJson(file)
        if (fromJson != null) return fromJson

        println("Error on loading prompt data from '${file.path}'. Neither bytes nor json.")
        return null
    }


    /**
     * Loads a [PromptsManager] object from a byte array, which should be saved
     * through the [ParsedPrompts.serializeBinary] method.
     *
     * It uses [ProtoBuf.decodeFromByteArray] to read the serialized object from
     * the byte array. If an error occurs during deserialization, it returns `null`.
     *
     * @param filePath The path to the file containing the serialized prompt Binary data to load.
     *
     * @return The deserialized [PromptsManagerImpl] object, or `null` if deserialization fails.
     */
    fun fromBytes(filePath: String): PromptsManager? {
        return fromBytes(File(filePath))
    }


    /**
     * Loads a [PromptsManager] object from a byte array, which should be saved
     * through the [ParsedPrompts.serializeBinary] method.
     *
     * It uses [ProtoBuf.decodeFromByteArray] to read the serialized object from
     * the byte array. If an error occurs during deserialization, it returns `null`.
     *
     * @param file The file containing the serialized prompt Binary data to load.
     *
     * @return The deserialized [PromptsManagerImpl] object, or `null` if deserialization fails.
     */
    @OptIn(ExperimentalSerializationApi::class) // TODO check for not experimental library
    fun fromBytes(file: File): PromptsManager? {
        val parsedPrompts = deserialize(file) { it: ByteArray ->
            ProtoBuf.decodeFromByteArray(ParsedPrompts.serializer(), it)
        }
        return parsedPrompts?.getPromptManager()
    }


    /**
     * Deserializes a [PromptsManager] object from a Json string, which should be saved
     * through the [ParsedPrompts.serializeJson] method.
     *
     * It uses [Json.decodeFromString] to read the serialized object from the file.
     * If an error occurs during deserialization, it returns `null`.
     *
     * @param filePath The path to the file containing the serialized prompt Json data to load.
     *
     * @return The deserialized [PromptsManagerImpl] object, or `null` if deserialization fails.
     */
    fun fromJson(filePath: String): PromptsManager? {
        return fromJson(File(filePath))
    }


    /**
     * Deserializes a [PromptsManager] object from a Json string, which should be saved
     * through the [ParsedPrompts.serializeJson] method.
     *
     * It uses [Json.decodeFromString] to read the serialized object from the file.
     * If an error occurs during deserialization, it returns `null`.
     *
     * @param file The file containing the serialized prompt Json data to load.
     *
     * @return The deserialized [PromptsManagerImpl] object, or `null` if deserialization fails.
     */
    fun fromJson(file: File): PromptsManager? {
        val parsedPrompts = deserialize(file) { it: String ->
            Json.decodeFromString<ParsedPrompts>(it)
        }
        return parsedPrompts?.getPromptManager()
    }


    /**
     * Deserializes a [ParsedPrompts] object from the given file, which should be saved
     * through the [ParsedPrompts.serializeJson] or [ParsedPrompts.serializeBinary] method.
     * If an error occurs during deserialization, it returns `null`.
     *
     * @param T the type of serialized data, which should be either `ByteArray` or `String`.
     *
     * @param file  The file containing the serialized prompt data to load.
     * @param setData A lambda function that receives data from a file and deserializes it.
     * The received data can be of type `ByteArray` or `String` only.
     *
     * @return The deserialized [ParsedPrompts] object, or `null` if deserialization fails.
     */
    private inline fun <reified T> deserialize(file: File, setData:  (data: T) -> ParsedPrompts ): ParsedPrompts? {
        try {
            val data = when (T::class) {
                ByteArray::class -> file.readBytes() as T // Read a ByteArray from the file
                String::class -> file.readText() as T // Read a String from the file
                else -> println("ERROR unsupported serialized data type to write to '${file.path}'.") as T
            }
            val parsedPrompts = setData(data)
            println("ParsedPrompts successfully deserialized from '${file.path}'.")
            return parsedPrompts
        }catch (ex: Exception){
            println("Error on deserializing prompt data from '${file.path}'. ${ex.message}")
            ex.printStackTrace()
            return null
        }
    }

}
